"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocSwagger = void 0;
const OutputFile_1 = require("./OutputFile");
const js_yaml_1 = require("js-yaml");
const DocUtils_1 = require("./DocUtils");
const lodash_1 = require("lodash");
const Testcase_1 = require("./Testcase");
const jsonSchemaOptions = undefined;
class DocSwagger extends OutputFile_1.OutputFile {
    constructor(attrs) {
        super(attrs);
    }
    exec() {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const cnt = lodash_1.merge({
                openapi: '3.0.1',
                info: {
                    title: self.tc.title,
                    description: self.tc.description,
                    version: self.tc.version,
                    contact: {
                        email: self.tc.developer || ''
                    }
                },
                servers: Object.keys(self.tc.servers).map(des => {
                    return {
                        url: self.tc.servers[des],
                        description: des
                    };
                }),
                paths: {},
                components: {
                    schemas: {}
                }
            }, this.raw);
            const apis = Testcase_1.Testcase.APIs.filter(api => api.docs);
            apis.forEach((api) => {
                var _a, _b, _c, _d;
                const pathName = api.url.url;
                if (!cnt.paths[pathName])
                    cnt.paths[pathName] = {};
                const method = api.method.toString().toLowerCase();
                const rs = Object.assign({ summary: ((_b = (_a = api.docs) === null || _a === void 0 ? void 0 : _a.swagger) === null || _b === void 0 ? void 0 : _b.summary) || api.title, parameters: [] }, (_c = api.docs) === null || _c === void 0 ? void 0 : _c.swagger);
                cnt.paths[pathName][method] = rs;
                if (api.url.hasParams) {
                    Object.keys(api.url.params).forEach(k => {
                        const p = api.url.params[k];
                        rs.parameters.push({
                            in: 'path',
                            name: p.name,
                            required: p.required,
                            example: p.value,
                            schema: DocUtils_1.toJsonSchema(p.value, jsonSchemaOptions)
                        });
                    });
                }
                if (api.url.hasQuery) {
                    Object.keys(api.url.query).forEach(k => {
                        const p = api.url.query[k];
                        rs.parameters.push({
                            in: 'query',
                            name: p.name,
                            required: p.required,
                            example: p.value,
                            schema: DocUtils_1.toJsonSchema(p.value, jsonSchemaOptions)
                        });
                    });
                }
                if (DocUtils_1.isGotData(this.headers)) {
                    let arrs = Object.keys(api.headers);
                    if (DocUtils_1.isGotData(this.headers)) {
                        arrs = arrs.filter(e => this.headers.includes(e));
                    }
                    arrs.forEach(q => {
                        rs.parameters.push({
                            in: 'header',
                            name: q,
                            example: api.headers[q],
                            schema: DocUtils_1.toJsonSchema(api.headers[q], jsonSchemaOptions)
                        });
                    });
                }
                if (DocUtils_1.isGotData(api.body)) {
                    rs.requestBody = lodash_1.merge({}, rs.requestBody || {}, {
                        content: {
                            'application/json': {
                                example: api.body,
                                schema: DocUtils_1.toJsonSchema(api.body, jsonSchemaOptions)
                            }
                        }
                    });
                }
                if (DocUtils_1.isGotData(api.response)) {
                    rs.responses = lodash_1.merge({}, rs.responses || {}, {
                        [api.response.status]: {
                            description: 'Success'
                        }
                    });
                    if (DocUtils_1.isGotData(api.response.data, false)) {
                        const [contentType] = (_d = api.response.headers['content-type']) === null || _d === void 0 ? void 0 : _d.split(';');
                        rs.responses[api.response.status].content = {
                            [contentType]: {
                                example: api.response.data,
                                schema: DocUtils_1.toJsonSchema(api.response.data, jsonSchemaOptions)
                            }
                        };
                    }
                    let arrs = Object.keys(api.response.headers);
                    if (DocUtils_1.isGotData(this.responseHeaders)) {
                        arrs = arrs.filter(e => this.responseHeaders.includes(e));
                    }
                    rs.responses[api.response.status].headers = arrs.reduce((sum, e) => {
                        sum[e] = {
                            description: api.response.headers[e],
                            schema: DocUtils_1.toJsonSchema(api.response.headers[e], jsonSchemaOptions)
                        };
                        return sum;
                    }, {});
                }
            });
            this.content = js_yaml_1.dump(cnt);
            if (!this.title)
                this.title = 'Swagger document';
            yield this.save();
        });
    }
}
exports.DocSwagger = DocSwagger;
//# sourceMappingURL=DocSwagger.js.map
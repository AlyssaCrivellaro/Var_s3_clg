"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validate = void 0;
const Tag_1 = require("./Tag");
const jsonschema_1 = require("jsonschema");
const lodash_1 = require("lodash");
const chalk_1 = __importDefault(require("chalk"));
const global_config_1 = require("../global_config");
Object.assign(global_config_1.globalConfig.validate, {
    schema(data, schema, opts) {
        var v = new jsonschema_1.Validator();
        const rs = v.validate(data, schema, opts);
        if (!rs.valid) {
            throw {
                message: rs.errors.map(e => e.stack).join('\n'),
                actual: JSON.stringify(data),
                expect: JSON.stringify(schema),
            };
        }
    },
    length(a, b) {
        if ((!Array.isArray(a) && typeof a !== 'string') || typeof b !== 'number')
            throw {
                message: 'Data type not match',
                actual: a,
                expect: b
            };
        if (a.length !== b)
            throw {
                message: 'Length not match',
                actual: a.length,
                expect: b
            };
    },
    match(a, b) {
        if (!lodash_1.isEqual(a, b))
            throw {
                message: 'Data not match',
                actual: a,
                expect: b
            };
    },
    in(a, b) {
        if (!b.includes(a)) {
            throw {
                message: 'Data not in',
                actual: a,
                expect: b
            };
        }
    }
});
global_config_1.globalConfig.event.on('log:validate', (e) => {
    if (!e.error) {
        if (!e.slient) {
            global_config_1.globalConfig.log('- %s %s', chalk_1.default.green('✔️'), chalk_1.default.magenta(e.title));
        }
    }
    else {
        global_config_1.globalConfig.group('- %s %s: %s', chalk_1.default.red('❌'), chalk_1.default.bgRed(e.title), chalk_1.default.red(e.error.message || ''));
        if (e.error.actual || e.error.expect) {
            global_config_1.globalConfig.error('  + %s', chalk_1.default.red('actual'), e.error.actual);
            global_config_1.globalConfig.error('  + %s', chalk_1.default.green('expect'), e.error.expect);
        }
        global_config_1.globalConfig.groupEnd();
    }
});
class Validate extends Tag_1.Tag {
    constructor(attrs) {
        super(attrs);
        if (this.script) {
            this.disabled = true;
            const { validate } = global_config_1.globalConfig;
            eval(`validate['${this.func}'] = ${this.script}`);
        }
    }
    prepare(scope) {
        return super.prepare(scope);
    }
    exec() {
        return __awaiter(this, void 0, void 0, function* () {
            const func = global_config_1.globalConfig.validate[this.func];
            if (!func)
                throw new Error(`Could not found validate "${this.func}"`);
            try {
                yield func(...this.args);
            }
            catch (err) {
                this.error = err;
            }
            finally {
                global_config_1.globalConfig.event.emit('log:validate', this);
            }
            return this.error;
        });
    }
}
exports.Validate = Validate;
//# sourceMappingURL=Validate.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = exports.REMOVE_CHARACTER = void 0;
const lodash_1 = require("lodash");
const global_config_1 = require("../global_config");
exports.REMOVE_CHARACTER = null;
class Tag {
    constructor(attrs) {
        lodash_1.merge(this, attrs);
    }
    prepare(scope, ignore = []) {
        var _a, _b;
        if (this.vars) {
            this.vars = Tag.replaceVars(this.vars, Object.assign(Object.assign({}, global_config_1.globalConfig.vars), { $vars: global_config_1.globalConfig.vars, $: scope || this, $$: (_a = (scope || this)) === null || _a === void 0 ? void 0 : _a.$$, $utils: global_config_1.globalConfig.utils }), []);
            Object.assign(global_config_1.globalConfig.vars, this.vars);
        }
        Tag.replaceVars(this, Object.assign(Object.assign({}, global_config_1.globalConfig.vars), { $vars: global_config_1.globalConfig.vars, $: scope || this, $$: (_b = (scope || this)) === null || _b === void 0 ? void 0 : _b.$$, $utils: global_config_1.globalConfig.utils }), ['steps', 'var', 'vars', 'templates', ...ignore]);
    }
    static replaceVars(obj, context = global_config_1.globalConfig.vars, ignores = []) {
        ignores.push('tc', 'group', 'attrs', '$$', 'steps');
        return Tag._replaceVars(obj, context, ignores);
    }
    static _replaceVars(obj, context = {}, ignores = []) {
        if (obj === null || obj === undefined)
            return obj;
        if (Array.isArray(obj)) {
            for (let i = 0; i < obj.length; i++) {
                obj[i] = Tag._replaceVars(obj[i], context);
            }
        }
        else if (typeof obj === 'object') {
            for (const _k in obj) {
                if (ignores.includes(_k))
                    continue;
                if (_k === '...') {
                    Tag._merge(obj, Tag._replaceVars(obj[_k], context));
                    delete obj[_k];
                }
                else {
                    const k = Tag._replaceVars(_k, context);
                    obj[k] = Tag._replaceVars(obj[_k], context);
                    if (k !== _k)
                        delete obj[_k];
                }
            }
        }
        else if (typeof obj === 'string') {
            let isHandlePattern;
            let m = obj.match(Tag.PatternVars.Object);
            if (m) {
                try {
                    obj = eval(Tag._getFunc(m[1], context));
                }
                catch (err) {
                    throw new Error(`Replace variable "${m[1]}" error`);
                }
                isHandlePattern = true;
            }
            else {
                const isOk = Tag.PatternVars.String.test(obj);
                if (isOk) {
                    try {
                        obj = eval(Tag._getFunc(`\`${obj}\``, context));
                    }
                    catch (err) {
                        throw new Error(`Replace variable "${obj}" error`);
                    }
                    isHandlePattern = true;
                }
            }
            if (isHandlePattern && typeof obj === 'string' && /\$\{[^\}]+\}/.test(obj)) {
                const nvl = Tag._replaceVars(obj, context);
                if (nvl !== obj)
                    obj = nvl;
            }
        }
        return obj;
    }
    static _getFunc(obj, context) {
        const declare = Object.keys(context).map(k => `const ${k} = context.${k}`).join('\n');
        return `(() => {
      ${declare}
      return ${obj}
    })()`;
    }
    static _merge(a, ...b) {
        return lodash_1.mergeWith(a, ...b.map(b => {
            const flat = b['...'];
            if (!flat)
                return b;
            delete b['...'];
            if (Array.isArray(flat)) {
                let obj = {};
                for (const a of flat) {
                    obj = Tag._merge({}, obj, a);
                }
                return Tag._merge({}, obj, b);
            }
            else {
                return Tag._merge({}, flat, b);
            }
        }), (a, b) => {
            if (Array.isArray(a) && Array.isArray(b)) {
                const rs = lodash_1.merge([], a, b);
                return rs.filter(e => e !== exports.REMOVE_CHARACTER);
            }
        });
    }
}
exports.Tag = Tag;
Tag.PatternVars = {
    Object: /^\$\{((?!.*(\$\{)).*)\}$/sm,
    String: /\$\{([^\}]+)\}+/sm,
};
//# sourceMappingURL=Tag.js.map